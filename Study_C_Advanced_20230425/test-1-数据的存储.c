#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>

//P99-P105

//本章重点
//1.数据类型详细介绍
//2.整型在内存中的存储：原码、反码、补码
//3.大小端字节序介绍及判断
//4.浮点型在内存中的存储解析


//数据类型的介绍
// char				字符数据类型
// short			短整型
// int				整型
// long				长整型
// long long		更长整型
// float			单精度浮点型
// double			双精度浮点型

//类型的意义
//1.使用这个类型开辟内存空间的大小（大小决定了使用范围）
//2.如何看待内存空间的视角


//整型家族
/*
char
	unsigned char
	signed char
short
	unsigned short [int]
	signed short [int]
int
	unsigned int
	signed int
long
	unsigned long [int]
	signed long [int]
*/

//浮点数家族
/*
float
double
*/

//构造类型 - 自定义类型
//struct	结构体类型
//数组
//enum		枚举
//union		联合体

//指针类型

//空类型
//void		
//函数的返回类型	void test();
//函数参数			void test(void);
//指针				void* p;



//
//int main()
//{
//	int a = -10;
//	//原码		先写符号位
//	//10000000 00000000 00000000 00001010 - 原码：按照数据的数值直接写出的二进制序列就是原码
//	//11111111 11111111 11111111 11110101 - 反码：原码的符号位不变，其他位按位取反，得到的就是反码
//	//11111111 11111111 11111111 11110110 - 补码：反码+1就是补码
//	//FF FF FF F6	整数在内存中存的是其二进制的补码
//
//	int b = 10;
//
//	return 0;
//}
//数据在内存中以2进制的形式存储
//对于整数来说，整数二进制有三种表示形式：原码、反码、补码
//正整数：原码、反码、补码相同
//负整数：原码、反码、补码都要进行计算

//对于整型来说：数据存放在内存中其实存放的是补码
//在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；
//同时，加法和减法也可以统一处理（CPU只有加法器）。此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路


//大端字节序和小端字节序
//int main()
//{
//	int a = 0x11223344;
//	//低地址 ---------------------------------------- 高地址
//	//			11	22	33	44		大端字节序：把数据的低位字节序的内容放在高地址处，高位字节序的内容放在低地址处
//	//			44	33	22	11		小端字节序：把数据的低位字节序的内容放在低地址处，高位字节序的内容放在高地址处
//	//vs采用小端字节模式
//	return 0;
//}


//写一个代码，判断当前机器的字节序是大端字节序还是小端字节序
//int main()
//{
//	int a = 1;
//	char* p = (char*)&a;
//	if (*p == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//	return 0;
//}

//或者写个函数
//int check_sys()
//{
//	int a = 1;
//	char* p = (char*)&a;
//	return *p;				//返回1表示大端，返回0表示小端
//}
//int main()
//{
//	int ret = check_sys();
//	if (ret == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//	return 0;
//}



//int main()
//{
//	char a = -1;
//	//10000000 00000000 00000000 00000001		
//	//11111111 11111111 11111111 11111110
//	//11111111 11111111 11111111 11111111		整型提升
//	//11111111									最后a里面存的是这个
//	//11111111 11111111 11111111 11111111		打印的时候，负数整型提升，高位补1
//
//	signed char b = -1;
//	//11111111									最后b里面存的是这个
//
//	unsigned char c = -1;
//	//11111111									最后c里面存的是这个
//	//00000000 00000000 00000000 11111111		无符号位整型提升，高位补0			
//	//00000000 00000000 00000000 11111111		整数补码翻译成原码相同
//
//	//abc里存放的东西都一样，但是，理解不一样
//	printf("a=%d,b=%d,c=%d", a, b, c);
//	return 0;
//}

//补充：
//1.char到底是signed char 还是 unsigned char
//c语言并标准没有规定，取决于编译器
//
//int是signed int
//short是signed short



//int main()
//{
//	char a = -128;
//	//10000000 00000000 00000000 10000000		原码
//	//11111111 11111111 11111111 01111111		反码
//	//11111111 11111111 11111111 10000000		补码
//	//10000000									存储
//	//11111111 11111111 11111111 10000000		打印时，先整型提升，%u为无符号数，因此前面那个1不作为符号位
//	printf("%u\n", a);
//
//	char b = 128;
//	//00000000 00000000 00000000 10000000		原码、反码、补码
//	//10000000									存储
//	//11111111 11111111 11111111 10000000		打印时，先整型提升，%u为无符号数，因此前面那个1不作为符号位
//	printf("%u\n", b);
//	return 0;
//}
//char类型取值范围
//11111111 ... 00000000 ... 01111111		-128~127


//int main()
//{
//	int i = -20;
//	//10000000 00000000 00000000 00010100		原
//	//11111111 11111111 11111111 11101011		反
//	//11111111 11111111 11111111 11101100		补
//
//	unsigned int j = 10;
//	//00000000 00000000 00000000 00001010		原反补
//
//	//i+j
//	//11111111 11111111 11111111 11110110		补
//	//11111111 11111111 11111111 11110101		反
//	//10000000 00000000 00000000 00001010		原		-10
//	printf("%d\n", i + j);
//	return 0;
//}


//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)			//死循环，无符号数 >=0 恒成立
//	{
//		printf("%u\n", i);
//	}
//	return 0;
//}


//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	//-1 -2 -3 ... -127 -128 127 126 125 ... 3 2 1 0 -1 -2 ... -127 -128 127
//
//	printf("%d", strlen(a));			//strlen()函数找到‘\0’就停止，‘\0’的ascⅡ码是0
//
//	return 0;
//}

//unsigned char i = 0;					//无符号char范围	0~255
//int main()
//{
//	for (i = 0; i <= 255; i++)			//每次i=255后，会回到0
//	{
//		printf("hello world\n");
//	}
//	return 0;
//}




//浮点型在内存中的存储
//limit.h 定义着整型的取值范围 int short char
//float.h 定义着浮点型的取值范围 float double
//int main()
//{
//	int n = 9;
//	float* pFloat = (float*)&n;
//	printf("n的值为：%d\n", n);
//	printf("*pFloat的值为：%f\n", *pFloat);
//
//	*pFloat = 9.0;
//	printf("num的值为：%d\n", n);
//	printf("*pFloat的值为：%f\n", *pFloat);
//	return 0;
//}
//浮点数和整数在内存中存储的方式不同

//根据国际标准IEEE1（电气和电子工程协会）754，任意一个二进制浮点数V可以表示成下面的形式：
//(-1)^S*M*2^E
//(-1)^S表示符号位，当s=0，V为正数；当s=1，V为负数。
//M表示有效数字，大于等于1，小于2.
//2^E表示指数位

//浮点数：5.5 - 10进制
//二进制：101.1 --> 1.011*2^2 --> (-1)^0*1.011*2^2 -->s=0;M=1.011;E=2

//对于float类型：	S		E		M
//					1bit	8bit	23bit		单精度浮点数存储模型

//对于double类型：	S		E		M
//					1bit	11bit	52bit		双精度浮点数存储模型

//对于M
//IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍弃，只保存后面的xxxxxxx部分。
//比如保持1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，节省1位有效数字。
//以32位浮点数为例，留给M的只有23位，将第一位的1舍弃以后，等于可以保存24位有效数字。

//对于E
//E为一个无符号正数（unsigned int），这意味着，如果E为8为，它的取值范围为0~255；如果E为11位，它的取值范围为0~2047.
//但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，存入内存时E的真实值必须再加上一个中间数，
//对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023.
//比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001

//int main()
//{
//	float f = 5.5f;
//	//101.1
//	//1.011*2^2
//	//s=0;	M=1.011;	E=2
//	//S=0;	M=011;		E=2+127=129
//	//0100 0000  1011 0000  0000 0000  0000 0000
//	//4 0  b 0  0 0  0 0
//	return 0;
//}
//指数E从内存中取出来还可以再分成三种情况：
/*
1.E不全为0或不全为1
  这时，浮点数就采用下面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。
  比如：0.5（1/2）的二进制形式为0.1，由于规定正数部分必须为1，即将小数点右移1位，则为1.0*2^(-1)
  其阶码为-1+127=126，表示为01111110，而位数1.0去掉整数部分为0，补齐0到23位00000000000000000000000
  则其二进制表示形式为：0 01111110 00000000000000000000000

2.E全为0
  这时，浮点数的指数E等于1-127（或者1-1023）即为真实值，有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。
  这样做是为了表示±0，以及接近于0的很小的数字。

3.E全为1
  这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）
*/

//int main()
//{
//	int n = 9;
//	//n			00000000 00000000 00000000 00001001
//	float* pFloat = (float*)&n;
//	printf("n的值为：%d\n", n);
//	printf("*pFloat的值为：%f\n", *pFloat);
//	//*pFloat	0 00000000 00000000000000000001001		E为全0 --> 即真实值为很小的一个数
//	//			s	E		M
//
//	*pFloat = 9.0;
//	//9 --> 1001.0 --> 1.001*2^3 -->S=0 ; E=3+127=130 ; M=001
//	//0 10000010 00100000000000000000000
//	printf("num的值为：%d\n", n);						//n --> 01000001 00010000 00000000 00000000
//	printf("*pFloat的值为：%f\n", *pFloat);
//	return 0;
//}
